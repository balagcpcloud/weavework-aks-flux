{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>TF-controller is an experimental controller for Flux to reconcile Terraform resources in the GitOps way. With the power of Flux together with Terraform, TF-controller allows you to GitOps-ify infrastructure, and application resources, in the Kubernetes and Terraform universe, at your own pace.</p> <p>\"At your own pace\" means you don't need to GitOps-ify everything at once.</p> <p>TF-controller offers many GitOps models:</p> <ol> <li>GitOps Automation Model: GitOps your Terraform resources from the provision steps to the enforcement steps, like a whole EKS cluster.</li> <li>Hybrid GitOps Automation Model: GitOps parts of your existing infrastructure resources. For example, you have an existing EKS cluster.      You can choose to GitOps only its nodegroup, or its security group.</li> <li>State Enforcement Model: You have a TFSTATE file, and you'd like to use GitOps enforce it, without changing anything else.</li> <li>Drift Detection Model: You have a TFSTATE file, and you'd like to use GitOps just for drift detection, so you can decide to do things later when a drift occurs.</li> </ol> <p>To get started, follow the getting started guide.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Multi-Tenancy: TF-controller supports multi-tenancy by running Terraform <code>plan</code> and <code>apply</code> inside Runner Pods.     When specifying <code>.metadata.namespace</code> and <code>.spec.serviceAccountName</code>, the Runner Pod uses the specified ServiceAccount     and runs inside the specified Namespace. These settings enable the soft multi-tenancy model, which can be used within     the Flux multi-tenancy setup. This feature is available since v0.9.0.</li> <li>GitOps Automation for Terraform: With setting <code>.spec.approvePlan=auto</code>, it allows a <code>Terraform</code> object     to be reconciled and act as the representation of your Terraform resources. The TF-controller uses the spec of     the <code>Terraform</code> object to perform <code>plan</code>, <code>apply</code> its associated Terraform resources. It then stores     the <code>TFSTATE</code> of the applied resources as a <code>Secret</code> inside the Kubernetes cluster. After <code>.spec.interval</code> passes,     the controller performs drift detection to check if there is a drift occurred between your live system,     and your Terraform resources. If a drift occurs, the plan to fix that drift will be generated and applied automatically.     This feature is available since v0.3.0.</li> <li>Drift detection: This feature is a part of the GitOps automation feature. The controller detects and fixes drift     for your infrastructures, based on the Terraform resources and their <code>TFSTATE</code>. This feature is available since v0.5.0.<ul> <li>Drift detection is enabled by default. You can use the field <code>.spec.disableDriftDetection</code> to disable this behaviour.   This feature is available since v0.7.0.</li> <li>The Drift detection only mode, without plan or apply steps, allows you to perform read-only drift detection.   This feature is available since v0.8.0.</li> </ul> </li> <li>Plan and Manual Approve: This feature allows you to separate the <code>plan</code>, out of the <code>apply</code> step, just like     the Terraform workflow you are familiar with. A good thing about this is that it is done in a GitOps way. When a plan     is generated, the controller shows you a message like 'set approvePlan: \"plan-main-123\" to apply this plan.'.     You make change to the field <code>.spec.approvePlan</code>, commit and push to tell the TF-controller to apply the plan for you.     With this GitOps workflow, you can optionally create and push this change to a new branch for your team member to     review and approve too. This feature is available since v0.6.0.</li> <li>First-class YAML-based Terraform: The <code>Terraform</code> object in v0.13.0+ allows you to better configure your      Terraform resources via YAMLs, but without introducing any extra CRDs to your cluster. Together with a new generator     called Tofu-Jet, we'll now be able to ship pre-generated primitive Terraform modules for all major cloud providers.     A primitive Terraform module is a module that only contains a single primitive resource, like <code>aws_iam_role</code>, or <code>aws_iam_policy</code>.     With this concept, we would be able to use Terraform without writing Terraform codes, and make it more GitOps-friendly at the same time.      This feature is available since v0.13.0.</li> <li>GitOps Dependency for Terraform: The <code>Terraform</code> object in v0.13.0+ allows you to specify a list of <code>Terraform</code> objects     that it depends on. The controller will wait for the dependencies to be ready before it starts to reconcile the     <code>Terraform</code> object. This allows you to create a dependency graph of your Terraform modules, and make sure     the modules are applied in the correct order. Please use <code>.spec.retryInterval</code> (a small value like <code>20s</code>) to control      the retry interval when using this feature. This feature is available since v0.13.0.</li> </ul>"},{"location":"#support-matrix","title":"Support Matrix","text":"Version Terraform Source Controller Flux v2 v0.13.1 v1.3.1 v0.31.0 v0.36.x v0.12.0 v1.1.9 v0.26.1 v0.32.x"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#preflight-checks","title":"Preflight Checks","text":"<p>Here are the requirements you need to set up before you start:</p> <ol> <li>Flux v0.32.0 or later (not only the CLI, but also the controllers on the cluster). If you are not sure about the Flux version on your cluster, please re-bootstrap your cluster.</li> <li>TF-controller uses the Controller/Runner architecture. The Controller acts as a client, and talks to each Runner's Pod via gRPC. Please make sure <ol> <li>Each Runner's Pod in each Namespace is allowed to open, and serve at port 30000 (the gRPC port of a Runner), and the Controller can connect to it.</li> <li>The Controller needs to download tar.gz BLOBs from the Source controller via port 80.</li> <li>The Controller needs to post the events to the Notification controller via port 80.</li> </ol> </li> </ol>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Before using TF-controller, you have to install Flux by using either <code>flux install</code> or <code>flux bootstrap</code> command. Please note that TF-controller now requires Flux v0.32.0 or later, so please make sure you have the latest version of Flux. After that you can install TF-controller with Flux HelmRelease by:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/weaveworks/tf-controller/main/docs/release.yaml\n</code></pre> <p>For the most recent release candidate of TF-controller, please use rc.yaml.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/weaveworks/tf-controller/main/docs/rc.yaml\n</code></pre> <p>or manually with Helm by:</p> <pre><code># Add tf-controller helm repository\nhelm repo add tf-controller https://weaveworks.github.io/tf-controller/\n\n# Install tf-controller\nhelm upgrade -i tf-controller tf-controller/tf-controller \\\n--namespace flux-system\n</code></pre> <p>For details on configurable parameters of the TF-controller chart, please see chart readme.</p> <p>Alternatively, you can install TF-controller via <code>kubectl</code>:</p> <pre><code>export TF_CON_VER=v0.13.1\nkubectl apply -f https://github.com/weaveworks/tf-controller/releases/download/${TF_CON_VER}/tf-controller.crds.yaml\nkubectl apply -f https://github.com/weaveworks/tf-controller/releases/download/${TF_CON_VER}/tf-controller.rbac.yaml\nkubectl apply -f https://github.com/weaveworks/tf-controller/releases/download/${TF_CON_VER}/tf-controller.deployment.yaml\n</code></pre>"},{"location":"getting_started/#quick-start","title":"Quick start","text":"<p>Here's a simple example of how to GitOps your Terraform resources with TF-controller and Flux.</p>"},{"location":"getting_started/#define-source","title":"Define source","text":"<p>First, we need to define a Source controller's source (<code>GitRepository</code>, <code>Bucket</code>, <code>OCIRepository</code>), for example:</p> <pre><code>apiVersion: source.toolkit.fluxcd.io/v1beta1\nkind: GitRepository\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\ninterval: 30s\nurl: https://github.com/tf-controller/helloworld\nref:\nbranch: main\n</code></pre>"},{"location":"getting_started/#the-gitops-automation-mode","title":"The GitOps Automation mode","text":"<p>The GitOps automation mode could be enabled by setting <code>.spec.approvePlan=auto</code>. In this mode, Terraform resources will be planned, and automatically applied for you.</p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\ninterval: 1m\napprovePlan: auto\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\n</code></pre> <p>For a full list of features and how to use them, please follow the Use TF-controller guide.</p>"},{"location":"getting_started/#other-examples","title":"Other Examples","text":"<ul> <li>A Terraform GitOps with Flux to automatically reconcile your AWS IAM Policies.</li> <li>GitOps an existing EKS cluster, by partially import its nodegroup and manage it with TF-controller: An EKS scaling example.</li> </ul>"},{"location":"tfctl/","title":"tfctl","text":"<p><code>tfctl</code> is a command-line utility to help with tf-controller operations.</p>"},{"location":"tfctl/#installation","title":"Installation","text":"<p>You can download the <code>tfctl</code> binary via the GitHub releases page: https://github.com/weaveworks/tf-controller/releases</p> <pre><code>Usage:\n  tfctl [command]\n\nAvailable Commands:\n  completion  Generate the autocompletion script for the specified shell\n  create      Create a Terraform resource\n  delete      Delete a Terraform resource\n  get         Get Terraform resources\n  help        Help about any command\n  install     Install the tf-controller\n  plan        Plan a Terraform configuration\n  reconcile   Trigger a reconcile of the provided resource\n  resume      Resume reconciliation for the provided resource\n  suspend     Suspend reconciliation for the provided resource\n  uninstall   Uninstall the tf-controller\n  version     Prints tf-controller and tfctl version information\n\nFlags:\n  -h, --help                help for tfctl\n      --kubeconfig string   Path to the kubeconfig file to use for CLI requests.\n  -n, --namespace string    The kubernetes namespace to use for CLI requests. (default \"flux-system\")\n      --terraform string    The location of the terraform binary. (default \"/usr/bin/terraform\")\n\nUse \"tfctl [command] --help\" for more information about a command.\n</code></pre>"},{"location":"References/terraform/","title":"API References","text":"Terraform API reference <p>Packages:</p> <ul> <li> infra.contrib.fluxcd.io/v1alpha1 </li> </ul>"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1","title":"infra.contrib.fluxcd.io/v1alpha1","text":"<p>Resource Types:</p>"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.BackendConfigSpec","title":"BackendConfigSpec","text":"<p> (Appears on: TerraformSpec) </p> <p>BackendConfigSpec is for specifying configuration for Terraform\u2019s Kubernetes backend</p> Field Description <code>disable</code>  bool  (Optional) <p>Disable is to completely disable the backend configuration.</p> <code>secretSuffix</code>  string  (Optional) <code>inClusterConfig</code>  bool  (Optional) <code>customConfiguration</code>  string  (Optional) <code>configPath</code>  string  (Optional) <code>labels</code>  map[string]string  (Optional)"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.BackendConfigsReference","title":"BackendConfigsReference","text":"<p> (Appears on: TerraformSpec) </p> Field Description <code>kind</code>  string  <p>Kind of the values referent, valid values are (\u2018Secret\u2019, \u2018ConfigMap\u2019).</p> <code>name</code>  string  <p>Name of the configs referent. Should reside in the same namespace as the referring resource.</p> <code>keys</code>  []string  (Optional) <p>Keys is the data key where a specific value can be found at. Defaults to all keys.</p> <code>optional</code>  bool  (Optional) <p>Optional marks this BackendConfigsReference as optional. When set, a not found error for the values reference is ignored, but any Key or transient error will still result in a reconciliation failure.</p>"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.CrossNamespaceSourceReference","title":"CrossNamespaceSourceReference","text":"<p> (Appears on: TerraformSpec) </p> <p>CrossNamespaceSourceReference contains enough information to let you locate the typed Kubernetes resource object at cluster level.</p> Field Description <code>apiVersion</code>  string  (Optional) <p>API version of the referent.</p> <code>kind</code>  string  <p>Kind of the referent.</p> <code>name</code>  string  <p>Name of the referent.</p> <code>namespace</code>  string  (Optional) <p>Namespace of the referent, defaults to the namespace of the Kubernetes resource object that contains the reference.</p>"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.FileMapping","title":"FileMapping","text":"<p> (Appears on: TerraformSpec) </p> Field Description <code>secretRef</code>  github.com/fluxcd/pkg/apis/meta.SecretKeyReference  <p>Reference to a Secret that contains the file content</p> <code>location</code>  string  <p>Location can be either user\u2019s home directory or the Terraform workspace</p> <code>path</code>  string  <p>Path of the file - relative to the \u201clocation\u201d</p>"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.ForceUnlockEnum","title":"ForceUnlockEnum (<code>string</code> alias)","text":"<p> (Appears on: TFStateSpec) </p>"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.HealthCheck","title":"HealthCheck","text":"<p> (Appears on: TerraformSpec) </p> <p>HealthCheck contains configuration needed to perform a health check after terraform is applied.</p> Field Description <code>name</code>  string  <p>Name of the health check.</p> <code>type</code>  string  <p>Type of the health check, valid values are (\u2018tcp\u2019, \u2018http\u2019). If tcp is specified, address is required. If http is specified, url is required.</p> <code>url</code>  string  (Optional) <p>URL to perform http health check on. Required when http type is specified. Go template can be used to reference values from the terraform output (e.g. https://example.org, {{.output_url}}).</p> <code>address</code>  string  (Optional) <p>Address to perform tcp health check on. Required when tcp type is specified. Go template can be used to reference values from the terraform output (e.g. 127.0.0.1:8080, {{.address}}:{{.port}}).</p> <code>timeout</code>  Kubernetes meta/v1.Duration  (Optional) <p>The timeout period at which the connection should timeout if unable to complete the request. When not specified, default 20s timeout is used.</p>"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.LockStatus","title":"LockStatus","text":"<p> (Appears on: TerraformStatus) </p> <p>LockStatus defines the observed state of a Terraform State Lock</p> Field Description <code>lastApplied</code>  string  (Optional) <code>pending</code>  string  (Optional) <p>Pending holds the identifier of the Lock Holder to be used with Force Unlock</p>"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.PlanStatus","title":"PlanStatus","text":"<p> (Appears on: TerraformStatus) </p> Field Description <code>lastApplied</code>  string  (Optional) <code>pending</code>  string  (Optional) <code>isDestroyPlan</code>  bool  (Optional) <code>isDriftDetectionPlan</code>  bool  (Optional)"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.ReadInputsFromSecretSpec","title":"ReadInputsFromSecretSpec","text":"<p> (Appears on: TerraformSpec) </p> Field Description <code>name</code>  string  <code>as</code>  string"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.ResourceInventory","title":"ResourceInventory","text":"<p> (Appears on: TerraformStatus) </p> <p>ResourceInventory contains a list of Kubernetes resource object references that have been applied by a Kustomization.</p> Field Description <code>entries</code>  []ResourceRef  <p>Entries of Kubernetes resource object references.</p>"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.ResourceRef","title":"ResourceRef","text":"<p> (Appears on: ResourceInventory) </p> <p>ResourceRef contains the information necessary to locate a resource within a cluster.</p> Field Description <code>n</code>  string  <p>Terraform resource\u2019s name.</p> <code>t</code>  string  <p>Type is Terraform resource\u2019s type</p> <code>id</code>  string  <p>ID is the resource identifier. This is cloud-specific. For example, ARN is an ID on AWS.</p>"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.RunnerPodMetadata","title":"RunnerPodMetadata","text":"<p> (Appears on: RunnerPodTemplate) </p> Field Description <code>labels</code>  map[string]string  (Optional) <p>Labels to add to the runner pod</p> <code>annotations</code>  map[string]string  (Optional) <p>Annotations to add to the runner pod</p>"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.RunnerPodSpec","title":"RunnerPodSpec","text":"<p> (Appears on: RunnerPodTemplate) </p> Field Description <code>image</code>  string  (Optional) <p>Runner pod image to use other than default</p> <code>envFrom</code>  []Kubernetes core/v1.EnvFromSource  (Optional) <p>List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.</p> <code>env</code>  []Kubernetes core/v1.EnvVar  (Optional) <p>List of environment variables to set in the container. Cannot be updated.</p> <code>nodeSelector</code>  map[string]string  (Optional) <p>Set the NodeSelector for the Runner Pod</p> <code>affinity</code>  Kubernetes core/v1.Affinity  (Optional) <p>Set the Affinity for the Runner Pod</p> <code>tolerations</code>  []Kubernetes core/v1.Toleration  (Optional) <p>Set the Tolerations for the Runner Pod</p> <code>volumeMounts</code>  []Kubernetes core/v1.VolumeMount  (Optional) <p>Set Volume Mounts for the Runner Pod</p> <code>volumes</code>  []Kubernetes core/v1.Volume  (Optional) <p>Set Volumes for the Runner Pod</p> <code>initContainers</code>  []Kubernetes core/v1.Container  (Optional) <p>Set up Init Containers for the Runner</p>"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.RunnerPodTemplate","title":"RunnerPodTemplate","text":"<p> (Appears on: TerraformSpec) </p> Field Description <code>metadata</code>  RunnerPodMetadata  (Optional) <code>spec</code>  RunnerPodSpec  (Optional) <code>image</code>  string  (Optional) <p>Runner pod image to use other than default</p> <code>envFrom</code>  []Kubernetes core/v1.EnvFromSource  (Optional) <p>List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.</p> <code>env</code>  []Kubernetes core/v1.EnvVar  (Optional) <p>List of environment variables to set in the container. Cannot be updated.</p> <code>nodeSelector</code>  map[string]string  (Optional) <p>Set the NodeSelector for the Runner Pod</p> <code>affinity</code>  Kubernetes core/v1.Affinity  (Optional) <p>Set the Affinity for the Runner Pod</p> <code>tolerations</code>  []Kubernetes core/v1.Toleration  (Optional) <p>Set the Tolerations for the Runner Pod</p> <code>volumeMounts</code>  []Kubernetes core/v1.VolumeMount  (Optional) <p>Set Volume Mounts for the Runner Pod</p> <code>volumes</code>  []Kubernetes core/v1.Volume  (Optional) <p>Set Volumes for the Runner Pod</p> <code>initContainers</code>  []Kubernetes core/v1.Container  (Optional) <p>Set up Init Containers for the Runner</p>"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.TFStateSpec","title":"TFStateSpec","text":"<p> (Appears on: TerraformSpec) </p> <p>TFStateSpec allows the user to set ForceUnlock</p> Field Description <code>forceUnlock</code>  ForceUnlockEnum  (Optional) <p>ForceUnlock a Terraform state if it has become locked for any reason. Defaults to <code>no</code>.</p> <p>This is an Enum and has the expected values of:</p> <ul> <li>auto</li> <li>yes</li> <li>no</li> </ul> <p>WARNING: Only use <code>auto</code> in the cases where you are absolutely certain that no other system is using this state, you could otherwise end up in a bad place See https://www.terraform.io/language/state/locking#force-unlock for more information on the terraform state lock and force unlock.</p> <code>lockIdentifier</code>  string  (Optional) <p>LockIdentifier holds the Identifier required by Terraform to unlock the state if it ever gets into a locked state.</p> <p>You\u2019ll need to put the Lock Identifier in here while setting ForceUnlock to either <code>yes</code> or <code>auto</code>.</p> <p>Leave this empty to do nothing, set this to the value of the <code>Lock Info: ID: [value]</code>, e.g. <code>f2ab685b-f84d-ac0b-a125-378a22877e8d</code>, to force unlock the state.</p>"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.Terraform","title":"Terraform","text":"<p>Terraform is the Schema for the terraforms API</p> Field Description <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  TerraformSpec  <code>approvePlan</code>  string  (Optional) <p>ApprovePlan specifies name of a plan wanted to approve. If its value is \u201cauto\u201d, the controller will automatically approve every plan.</p> <code>destroy</code>  bool  (Optional) <p>Destroy produces a destroy plan. Applying the plan will destroy all resources.</p> <code>backendConfig</code>  BackendConfigSpec  (Optional) <code>backendConfigsFrom</code>  []BackendConfigsReference  (Optional) <code>workspace</code>  string  (Optional) <code>vars</code>  []Variable  (Optional) <p>List of input variables to set for the Terraform program.</p> <code>varsFrom</code>  []VarsReference  (Optional) <p>List of references to a Secret or a ConfigMap to generate variables for Terraform resources based on its data, selectively by varsKey. Values of the later Secret / ConfigMap with the same keys will override those of the former.</p> <code>values</code>  Kubernetes pkg/apis/apiextensions/v1.JSON  (Optional) <p>Values map to the Terraform variable \u201cvalues\u201d, which is an object of arbitrary values. It is a convenient way to pass values to Terraform resources without having to define a variable for each value. To use this feature, your Terraform file must define the variable \u201cvalues\u201d.</p> <code>fileMappings</code>  []FileMapping  (Optional) <p>List of all configuration files to be created in initialization.</p> <code>interval</code>  Kubernetes meta/v1.Duration  <p>The interval at which to reconcile the Terraform.</p> <code>retryInterval</code>  Kubernetes meta/v1.Duration  (Optional) <p>The interval at which to retry a previously failed reconciliation. When not specified, the controller uses the TerraformSpec.Interval value to retry failures.</p> <code>path</code>  string  (Optional) <p>Path to the directory containing Terraform (.tf) files. Defaults to \u2018None\u2019, which translates to the root path of the SourceRef.</p> <code>sourceRef</code>  CrossNamespaceSourceReference  <p>SourceRef is the reference of the source where the Terraform files are stored.</p> <code>suspend</code>  bool  (Optional) <p>Suspend is to tell the controller to suspend subsequent TF executions, it does not apply to already started executions. Defaults to false.</p> <code>force</code>  bool  (Optional) <p>Force instructs the controller to unconditionally re-plan and re-apply TF resources. Defaults to false.</p> <code>readInputsFromSecrets</code>  []ReadInputsFromSecretSpec  (Optional) <code>writeOutputsToSecret</code>  WriteOutputsToSecretSpec  (Optional) <p>A list of target secrets for the outputs to be written as.</p> <code>disableDriftDetection</code>  bool  (Optional) <p>Disable automatic drift detection. Drift detection may be resource intensive in the context of a large cluster or complex Terraform statefile. Defaults to false.</p> <code>cliConfigSecretRef</code>  Kubernetes core/v1.SecretReference  (Optional) <code>healthChecks</code>  []HealthCheck  (Optional) <p>List of health checks to be performed.</p> <code>destroyResourcesOnDeletion</code>  bool  (Optional) <p>Create destroy plan and apply it to destroy terraform resources upon deletion of this object. Defaults to false.</p> <code>serviceAccountName</code>  string  (Optional) <p>Name of a ServiceAccount for the runner Pod to provision Terraform resources. Default to tf-runner.</p> <code>alwaysCleanupRunnerPod</code>  bool  (Optional) <p>Clean the runner pod up after each reconciliation cycle</p> <code>runnerTerminationGracePeriodSeconds</code>  int64  (Optional) <p>Configure the termination grace period for the runner pod. Use this parameter to allow the Terraform process to gracefully shutdown. Consider increasing for large, complex or slow-moving Terraform managed resources.</p> <code>refreshBeforeApply</code>  bool  (Optional) <p>RefreshBeforeApply forces refreshing of the state before the apply step.</p> <code>runnerPodTemplate</code>  RunnerPodTemplate  (Optional) <code>enableInventory</code>  bool  (Optional) <p>EnableInventory enables the object to store resource entries as the inventory for external use.</p> <code>tfstate</code>  TFStateSpec  (Optional) <code>targets</code>  []string  (Optional) <p>Targets specify the resource, module or collection of resources to target.</p> <code>parallelism</code>  int32  (Optional) <p>Parallelism limits the number of concurrent operations of Terraform apply step. Zero (0) means using the default value.</p> <code>storeReadablePlan</code>  string  (Optional) <p>StoreReadablePlan enables storing the plan in a readable format.</p> <code>webhooks</code>  []Webhook  (Optional) <code>dependsOn</code>  []github.com/fluxcd/pkg/apis/meta.NamespacedObjectReference  (Optional) <code>enterprise</code>  Kubernetes pkg/apis/apiextensions/v1.JSON  (Optional) <p>Enterprise is the enterprise configuration placeholder.</p> <code>status</code>  TerraformStatus"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.TerraformSpec","title":"TerraformSpec","text":"<p> (Appears on: Terraform) </p> <p>TerraformSpec defines the desired state of Terraform</p> Field Description <code>approvePlan</code>  string  (Optional) <p>ApprovePlan specifies name of a plan wanted to approve. If its value is \u201cauto\u201d, the controller will automatically approve every plan.</p> <code>destroy</code>  bool  (Optional) <p>Destroy produces a destroy plan. Applying the plan will destroy all resources.</p> <code>backendConfig</code>  BackendConfigSpec  (Optional) <code>backendConfigsFrom</code>  []BackendConfigsReference  (Optional) <code>workspace</code>  string  (Optional) <code>vars</code>  []Variable  (Optional) <p>List of input variables to set for the Terraform program.</p> <code>varsFrom</code>  []VarsReference  (Optional) <p>List of references to a Secret or a ConfigMap to generate variables for Terraform resources based on its data, selectively by varsKey. Values of the later Secret / ConfigMap with the same keys will override those of the former.</p> <code>values</code>  Kubernetes pkg/apis/apiextensions/v1.JSON  (Optional) <p>Values map to the Terraform variable \u201cvalues\u201d, which is an object of arbitrary values. It is a convenient way to pass values to Terraform resources without having to define a variable for each value. To use this feature, your Terraform file must define the variable \u201cvalues\u201d.</p> <code>fileMappings</code>  []FileMapping  (Optional) <p>List of all configuration files to be created in initialization.</p> <code>interval</code>  Kubernetes meta/v1.Duration  <p>The interval at which to reconcile the Terraform.</p> <code>retryInterval</code>  Kubernetes meta/v1.Duration  (Optional) <p>The interval at which to retry a previously failed reconciliation. When not specified, the controller uses the TerraformSpec.Interval value to retry failures.</p> <code>path</code>  string  (Optional) <p>Path to the directory containing Terraform (.tf) files. Defaults to \u2018None\u2019, which translates to the root path of the SourceRef.</p> <code>sourceRef</code>  CrossNamespaceSourceReference  <p>SourceRef is the reference of the source where the Terraform files are stored.</p> <code>suspend</code>  bool  (Optional) <p>Suspend is to tell the controller to suspend subsequent TF executions, it does not apply to already started executions. Defaults to false.</p> <code>force</code>  bool  (Optional) <p>Force instructs the controller to unconditionally re-plan and re-apply TF resources. Defaults to false.</p> <code>readInputsFromSecrets</code>  []ReadInputsFromSecretSpec  (Optional) <code>writeOutputsToSecret</code>  WriteOutputsToSecretSpec  (Optional) <p>A list of target secrets for the outputs to be written as.</p> <code>disableDriftDetection</code>  bool  (Optional) <p>Disable automatic drift detection. Drift detection may be resource intensive in the context of a large cluster or complex Terraform statefile. Defaults to false.</p> <code>cliConfigSecretRef</code>  Kubernetes core/v1.SecretReference  (Optional) <code>healthChecks</code>  []HealthCheck  (Optional) <p>List of health checks to be performed.</p> <code>destroyResourcesOnDeletion</code>  bool  (Optional) <p>Create destroy plan and apply it to destroy terraform resources upon deletion of this object. Defaults to false.</p> <code>serviceAccountName</code>  string  (Optional) <p>Name of a ServiceAccount for the runner Pod to provision Terraform resources. Default to tf-runner.</p> <code>alwaysCleanupRunnerPod</code>  bool  (Optional) <p>Clean the runner pod up after each reconciliation cycle</p> <code>runnerTerminationGracePeriodSeconds</code>  int64  (Optional) <p>Configure the termination grace period for the runner pod. Use this parameter to allow the Terraform process to gracefully shutdown. Consider increasing for large, complex or slow-moving Terraform managed resources.</p> <code>refreshBeforeApply</code>  bool  (Optional) <p>RefreshBeforeApply forces refreshing of the state before the apply step.</p> <code>runnerPodTemplate</code>  RunnerPodTemplate  (Optional) <code>enableInventory</code>  bool  (Optional) <p>EnableInventory enables the object to store resource entries as the inventory for external use.</p> <code>tfstate</code>  TFStateSpec  (Optional) <code>targets</code>  []string  (Optional) <p>Targets specify the resource, module or collection of resources to target.</p> <code>parallelism</code>  int32  (Optional) <p>Parallelism limits the number of concurrent operations of Terraform apply step. Zero (0) means using the default value.</p> <code>storeReadablePlan</code>  string  (Optional) <p>StoreReadablePlan enables storing the plan in a readable format.</p> <code>webhooks</code>  []Webhook  (Optional) <code>dependsOn</code>  []github.com/fluxcd/pkg/apis/meta.NamespacedObjectReference  (Optional) <code>enterprise</code>  Kubernetes pkg/apis/apiextensions/v1.JSON  (Optional) <p>Enterprise is the enterprise configuration placeholder.</p>"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.TerraformStatus","title":"TerraformStatus","text":"<p> (Appears on: Terraform) </p> <p>TerraformStatus defines the observed state of Terraform</p> Field Description <code>ReconcileRequestStatus</code>  github.com/fluxcd/pkg/apis/meta.ReconcileRequestStatus  <p> (Members of <code>ReconcileRequestStatus</code> are embedded into this type.) </p> <code>observedGeneration</code>  int64  (Optional) <p>ObservedGeneration is the last reconciled generation.</p> <code>conditions</code>  []Kubernetes meta/v1.Condition  (Optional) <code>lastAppliedRevision</code>  string  (Optional) <p>The last successfully applied revision. The revision format for Git sources is /. <code>lastAttemptedRevision</code>  string  (Optional) <p>LastAttemptedRevision is the revision of the last reconciliation attempt.</p> <code>lastPlannedRevision</code>  string  (Optional) <p>LastPlannedRevision is the revision used by the last planning process. The result could be either no plan change or a new plan generated.</p> <code>lastDriftDetectedAt</code>  Kubernetes meta/v1.Time  (Optional) <p>LastDriftDetectedAt is the time when the last drift was detected</p> <code>lastAppliedByDriftDetectionAt</code>  Kubernetes meta/v1.Time  (Optional) <p>LastAppliedByDriftDetectionAt is the time when the last drift was detected and terraform apply was performed as a result</p> <code>availableOutputs</code>  []string  (Optional) <code>plan</code>  PlanStatus  (Optional) <code>inventory</code>  ResourceInventory  (Optional) <p>Inventory contains the list of Terraform resource object references that have been successfully applied.</p> <code>lock</code>  LockStatus  (Optional)"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.Variable","title":"Variable","text":"<p> (Appears on: TerraformSpec) </p> Field Description <code>name</code>  string  <p>Name is the name of the variable</p> <code>value</code>  Kubernetes pkg/apis/apiextensions/v1.JSON  (Optional) <code>valueFrom</code>  Kubernetes core/v1.EnvVarSource  (Optional)"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.VarsReference","title":"VarsReference","text":"<p> (Appears on: TerraformSpec) </p> <p>VarsReference contain a reference of a Secret or a ConfigMap to generate variables for Terraform resources based on its data, selectively by varsKey.</p> Field Description <code>kind</code>  string  <p>Kind of the values referent, valid values are (\u2018Secret\u2019, \u2018ConfigMap\u2019).</p> <code>name</code>  string  <p>Name of the values referent. Should reside in the same namespace as the referring resource.</p> <code>varsKeys</code>  []string  (Optional) <p>VarsKeys is the data key at which a specific value can be found. Defaults to all keys.</p> <code>optional</code>  bool  (Optional) <p>Optional marks this VarsReference as optional. When set, a not found error for the values reference is ignored, but any VarsKey or transient error will still result in a reconciliation failure.</p>"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.Webhook","title":"Webhook","text":"<p> (Appears on: TerraformSpec) </p> Field Description <code>stage</code>  string  <code>enabled</code>  bool  (Optional) <code>url</code>  string  <code>payloadType</code>  string  (Optional) <code>errorMessageTemplate</code>  string  (Optional) <code>testExpression</code>  string"},{"location":"References/terraform/#infra.contrib.fluxcd.io/v1alpha1.WriteOutputsToSecretSpec","title":"WriteOutputsToSecretSpec","text":"<p> (Appears on: TerraformSpec) </p> <p>WriteOutputsToSecretSpec defines where to store outputs, and which outputs to be stored.</p> Field Description <code>name</code>  string  <p>Name is the name of the Secret to be written</p> <code>outputs</code>  []string  (Optional) <p>Outputs contain the selected names of outputs to be written to the secret. Empty array means writing all outputs, which is default.</p> <p>This page was automatically generated with <code>gen-crd-api-reference-docs</code></p>"},{"location":"how_to/","title":"How to","text":"<ul> <li>How to backup and restore a Terraform state</li> </ul>"},{"location":"how_to/backup_and_restore_a_Terraform_state/","title":"Backup and restore a Terraform state","text":""},{"location":"how_to/backup_and_restore_a_Terraform_state/#backup-the-tfstate","title":"Backup the tfstate","text":"<p>Assume that we have the <code>my-stack</code> Terraform object with its <code>.spec.workspace</code> set to \"default\".</p> <pre><code>kubectl get terraform\n\nNAME       READY     STATUS         AGE\nmy-stack   Unknown   Initializing   28s\n</code></pre> <p>We can backup its tfstate out of the cluster, like this:</p> <pre><code>WORKSPACE=default\nNAME=my-stack\n\nkubectl get secret tfstate-${WORKSPACE}-${NAME} \\\n-ojsonpath='{.data.tfstate}' \\\n| base64 -d | gzip -d &gt; terraform.tfstate\n</code></pre>"},{"location":"how_to/backup_and_restore_a_Terraform_state/#restore-the-tfstate","title":"Restore the tfstate","text":"<p>To restore the tfstate file or import an existing tfstate file to the cluster, we can use the following operation:</p> <pre><code>gzip terraform.tfstate\n\nWORKSPACE=default\nNAME=my-stack\n\nkubectl create secret \\\ngeneric tfstate-${WORKSPACE}-${NAME} \\\n--from-file=tfstate=terraform.tfstate.gz \\\n--dry-run=client -o=yaml \\\n| yq e '.metadata.annotations[\"encoding\"]=\"gzip\"' - \\\n&gt; tfstate-${WORKSPACE}-${NAME}.yaml\n\nkubectl apply -f tfstate-${WORKSPACE}-${NAME}.yaml\n</code></pre>"},{"location":"use_tf_controller/","title":"Use TF-controller","text":"<ul> <li>Use TF-controller to provision resources and auto approve</li> <li>Use TF-controller to plan and manually apply Terraform resources</li> <li>Use TF-controller to provision resources and obtain outputs</li> <li>Use TF-controller to detect drifts only without plan or apply</li> <li>Use TF-controller with drift detection disabled</li> <li>Use TF-controller with AWS EKS IRSA</li> <li>Use TF-controller to set variables for Terraform resources</li> <li>Use TF-controller with a custom backend</li> <li>Use TF-controller with an OCI Artifact as Source</li> <li>Use TF-controller to provision Terraform resources that are required health checks</li> <li>Use TF-controller to provision resources and destroy them when the Terraform object gets deleted</li> <li>Use TF-controller to force unlock Terraform states</li> <li>Use TF-controller to provision resources with customized Runner Pods</li> <li>Use TF-controller with Terraform Enterprise</li> <li>Use TF-controller with primitive modules</li> <li>Use TF-controller with GitOps dependency management</li> <li>Use TF-controller with the ready-to-use AWS package</li> </ul>"},{"location":"use_tf_controller/to_detect_drifts_only_without_plan_or_apply/","title":"To detect drifts only without plan or apply","text":""},{"location":"use_tf_controller/to_detect_drifts_only_without_plan_or_apply/#use-tf-controller-to-detect-drifts-only-without-plan-or-apply","title":"Use TF-controller to detect drifts only without plan or apply","text":"<p>We can set <code>.spec.approvePlan</code> to <code>disable</code> to tell the controller to detect drifts of your Terraform resources only. Doing so will skip the <code>plan</code> and <code>apply</code> stages.</p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: hello-world\nnamespace: flux-system\nspec:\napprovePlan: disable\ninterval: 1m\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\n</code></pre>"},{"location":"use_tf_controller/to_force_unlock_Terraform_states/","title":"Use TF-controller to force unlock Terraform states","text":"<p>In some situations, you may need to perform the Terraform force-unlock operation on the tfstate inside the cluster. </p> <p>There are three possible values of <code>.spec.tfstate.forceUnlock</code>, which are <code>yes</code>, <code>no</code>, and <code>auto</code>. The default value is <code>no</code>, which means that you disable this behaviour.</p> <p>The <code>auto</code> force-unlock mode will automatically use the lock identifier produced by the associated state file instead of specified lock identifier.</p> <p>The recommended way is to do manual force unlock. To manually <code>force-unlock</code>, you need to:</p> <ol> <li>set <code>forceUnlock</code> to <code>yes</code>, and</li> <li>specify a lock identifier to unlock a specific locked state,</li> </ol> <p>as the following example:</p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\napprovePlan: auto\ninterval: 1m\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\ntfstate:\nforceUnlock: \"yes\"\nlockIdentifier: f2ab685b-f84d-ac0b-a125-378a22877e8d\n</code></pre>"},{"location":"use_tf_controller/to_plan_and_manually_apply_Terraform_resources/","title":"Use TF-controller to plan and manually apply Terraform resources","text":"<p>Assume that you have a <code>GitRepository</code> object named <code>helloworld</code> pointing to a Git repository, and you want to plan and apply the Terraform resources under <code>./</code> of that Git repo.</p> <p>For the plan &amp; manual approval workflow, please start by either setting <code>.spec.approvePlan</code> to be the blank value, or omitting the field.</p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\napprovePlan: \"\" # or you can omit this field\ninterval: 1m\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\n</code></pre> <p>Then after a reconciliation loop, the controller will generate a plan, and tell you how to use field <code>.spec.approvePlan</code> to approve the plan. You can run the following command to obtain that message.</p> <pre><code>kubectl -n flux-system get tf/helloworld\n</code></pre> <p>After making change and push, it will apply the plan to create real resources.</p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: hello-world\nnamespace: flux-system\nspec:\napprovePlan: plan-main-b8e362c206 # first 8 digits of a commit hash is enough\ninterval: 1m\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\n</code></pre>"},{"location":"use_tf_controller/to_provision_Terraform_resources_that_are_required_health_checks/","title":"Use TF-controller to provision Terraform resources that are required health checks","text":"<p>For some Terraform resources, it may be useful to perform health checks on them to verify that they are ready to accept connection before the terraform goes into <code>Ready</code> state:</p> <p>For example, our Terraform file is provisioned and contains the following outputs.</p> <pre><code># main.tf\n\noutput \"rdsAddress\" {\n  value = \"mydb.xyz.us-east-1.rds.amazonaws.com\"\n}\n\noutput \"rdsPort\" {\n  value = \"3306\"\n}\n\noutput \"myappURL\" {\n  value = \"https://example.com/\"\n}\n</code></pre> <p>We can use standard Go template expressions, like <code>${{ .rdsAddress }}</code>, to refer to those output values and use them to verify that the resources are up and running.</p> <p>We support two types of health checks, <code>tcp</code> amd <code>http</code>. The <code>tcp</code> type allows us to verify a TCP connection, while the <code>http</code> type is for verify an HTTP URL. The default timeout of each health check is 20 seconds.</p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\napprovePlan: auto\ninterval: 1m\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\nhealthChecks:\n- name: rds\ntype: tcp\naddress: ${{ .rdsAddress }}:${{ .rdsPort }} timeout: 10s # optional, defaults to 20s\n- name: myapp\ntype: http\nurl: ${{ .myappURL }}\ntimeout: 5s\n- name: url_not_from_output\ntype: http\nurl: \"https://example.org\"\n</code></pre>"},{"location":"use_tf_controller/to_provision_resources_and_auto_approve/","title":"Use TF-controller to provision resources and auto approve","text":"<p>To provision resources with TF-controller, you need to create a <code>Terraform</code> object and a Flux source object,  such as a <code>GitRepository</code> or <code>OCIRepository</code> object.</p>"},{"location":"use_tf_controller/to_provision_resources_and_auto_approve/#create-a-terraform-object","title":"Create a Terraform object","text":"<p>The <code>Terraform</code> object is a Kubernetes custom resource definition (CRD) object. It is the core object of TF-controller. </p> <p>It defines the Terraform module, the backend configuration, and the GitOps automation mode.</p> <p>The Terraform module is a Terraform configuration that can be used to provision resources. It can be placed inside a Git repository, or packaged as an OCI image in an OCI registry.</p> <p>The backend configuration is the configuration for the Terraform backend to be used to store the Terraform state. It is optional. If not specified, the Kubernetes backend will be used by default.</p>"},{"location":"use_tf_controller/to_provision_resources_and_auto_approve/#gitops-automation-mode","title":"GitOps automation mode","text":"<p>the GitOps automation mode is the GitOps automation mode to be used to run the Terraform module. It is optional. If not specified, the \"plan-and-manually-apply\" mode will be used by default. In this example, we use the \"auto-apply\" mode.</p> <p>The following is an example of a <code>Terraform</code> object:</p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: helloworld\nspec:\npath: ./helloworld\ninterval: 10m\napprovePlan: auto\nsourceRef:\nkind: GitRepository\nname: helloworld\n</code></pre>"},{"location":"use_tf_controller/to_provision_resources_and_destroy_them_when_the_Terraform_object_gets_deleted/","title":"Use TF-controller to provision resources and destroy them when the Terraform object gets deleted","text":"<p>The resources provisioned by a Terraform object are not destroyed by default, and the tfstate of that Terraform object still remains in the cluster.</p> <p>It means that you are safe to delete the Terraform object in the cluster and re-create it.  If you re-create a new Terraform object with the same name, namespace and workspace, it will continue to use the tfstate inside the cluster as the starting point to reconcile.</p> <p>However, you may want to destroy provisioned resources when delete the Terraform object in many scenarios. To enable destroy resources on object deletion, set <code>.spec.destroyResourcesOnDeletion</code> to <code>true</code>.</p> <p>~&gt; WARNING: This feature will destroy your resources on the cloud if the Terraform object gets deleted. Please use it with cautions.</p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\napprovePlan: auto\ndestroyResourcesOnDeletion: true\ninterval: 1m\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\n</code></pre>"},{"location":"use_tf_controller/to_provision_resources_and_obtain_outputs/","title":"Use TF-controller to provision resources and obtain outputs","text":"<p>Outputs created by Terraform can be written to a secret using <code>.spec.writeOutputsToSecret</code>.</p>"},{"location":"use_tf_controller/to_provision_resources_and_obtain_outputs/#write-all-outputs","title":"Write all outputs","text":"<p>We can specify a target secret in <code>.spec.writeOutputsToSecret.name</code>, and the controller will write all outputs to the secret by default.</p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\napprovePlan: auto\ninterval: 1m\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\nwriteOutputsToSecret:\nname: helloworld-output\n</code></pre>"},{"location":"use_tf_controller/to_provision_resources_and_obtain_outputs/#write-outputs-selectively","title":"Write outputs selectively","text":"<p>We can choose only a subset of outputs by specify output names we'd like to write in the <code>.spec.writeOutputsToSecret.outputs</code> array.</p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\napprovePlan: auto\ninterval: 1m\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\nwriteOutputsToSecret:\nname: helloworld-output\noutputs:\n- hello_world\n- my_sensitive_data\n</code></pre>"},{"location":"use_tf_controller/to_provision_resources_and_obtain_outputs/#rename-outputs","title":"Rename outputs","text":"<p>Some time we'd like to use rename an output, so that it can be consumed by other Kubernetes controllers. For example, we might retrieve a key from a Secret manager, and it's an AGE key, which must be ending with \".agekey\" in the secret. In this case, we need to rename the output. </p> <p>TF-controller supports mapping output name using the <code>old_name:new_name</code> format.</p> <p>In the following example, we renamed <code>age_key</code> output as <code>age.agekey</code> entry for the <code>helloworld-output</code> Secret's data, so that other components in the GitOps pipeline could consume it.</p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\napprovePlan: auto\ninterval: 1m\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\nwriteOutputsToSecret:\nname: helloworld-output\noutputs:\n- age_key:age.agekey\n</code></pre>"},{"location":"use_tf_controller/to_provision_resources_with_customized_Runner_Pods/","title":"Use TF-controller to provision resources with customized Runner Pods","text":""},{"location":"use_tf_controller/to_provision_resources_with_customized_Runner_Pods/#customize-runner-pods-metadata","title":"Customize Runner Pod's metadata","text":"<p>In some situations, it is needed to add custom labels and annotations to the runner pod used to reconcile Terraform. For example, for Azure AKS to grant pod active directory permissions using Azure Active Directory (AAD) Pod Identity, a label like <code>aadpodidbinding: myIdentity</code> on the pod is required.</p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\napprovePlan: auto\ninterval: 1m\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\nrunnerPodTemplate:\nmetadata:\nlabels:\naadpodidbinding: myIdentity\nannotations:\ncompany.com/abc: xyz\n</code></pre>"},{"location":"use_tf_controller/to_provision_resources_with_customized_Runner_Pods/#customize-runner-pod-image","title":"Customize Runner Pod Image","text":"<p>By default, the Terraform controller uses <code>RUNNER_POD_IMAGE</code> environment variable to identify the Runner Pod's image to use. You can customize the image on the global level by updating the value of the environment variable or, you can specify an image to use per Terraform object for its reconciliation.</p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\napprovePlan: auto\ninterval: 1m\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\nrunnerPodTemplate:\nspec:\nimage: registry.io/tf-runner:xyz\n</code></pre> <p>You can use <code>runner.Dockerfile</code> as a basis of customizing runner pod image.</p>"},{"location":"use_tf_controller/to_provision_resources_with_customized_Runner_Pods/#customize-runner-pod-specifications","title":"Customize Runner Pod Specifications","text":"<p>You can also customize various Runner Pod <code>spec</code> fields to control and configure how the Runner Pod runs.  For example, you can configure Runner Pod <code>spec</code> affinity and tolerations if you need to run in on a specific set of nodes. Please see RunnerPodSpec for a list of the configurable Runner Pod <code>spec</code> fields.</p>"},{"location":"use_tf_controller/to_set_variables_for_Terraform_resources/","title":"Use TF-controller to set variables for Terraform resources","text":"<p>~&gt; BREAKING CHANGE: This is a breaking change of the <code>v1alpha1</code> API.</p> <p>Users who are upgrading from TF-controller &lt;= 0.7.0 require updating <code>varsFrom</code>, from a single object:</p> <pre><code>  varsFrom:\nkind: ConfigMap\nname: cluster-config\n</code></pre> <p>to be an array of object, like this:</p> <pre><code>  varsFrom:\n- kind: ConfigMap\nname: cluster-config\n</code></pre>"},{"location":"use_tf_controller/to_set_variables_for_Terraform_resources/#vars-and-varsfrom","title":"<code>vars</code> and <code>varsFrom</code>","text":"<p>You can pass variables to Terraform using the <code>vars</code> and <code>varsFrom</code> fields.</p> <p>Inline variables can be set using <code>vars</code>. The <code>varsFrom</code> field accepts a list of ConfigMaps / Secrets. You may use the <code>varsKeys</code> property of <code>varsFrom</code> to select specific keys from the input or omit this field to select all keys from the input source.</p> <p>Note that in the case of the same variable key being passed multiple times, the controller will use the lattermost instance of the key passed to <code>varsFrom</code>.</p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\napprovePlan: auto\ninterval: 1m\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\nvars:\n- name: region\nvalue: us-east-1\n- name: env\nvalue: dev\n- name: instanceType\nvalue: t3-small\nvarsFrom:\n- kind: ConfigMap\nname: cluster-config\nvarsKeys:\n- nodeCount\n- instanceType\n- kind: Secret\nname: cluster-creds\n</code></pre>"},{"location":"use_tf_controller/to_set_variables_for_Terraform_resources/#variable-value-as-hcl","title":"Variable value as HCL","text":"<p>The <code>vars</code> field supports HCL string, number, bool, object and list types. For example, the following variable can be populated using the accompanying Terraform spec:</p> <pre><code>variable \"cluster_spec\" {\n  type = object({\n      region     = string\n      env        = string\n      node_count = number\n      public     = bool\n  })\n}\n</code></pre> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\napprovePlan: auto\ninterval: 1m\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\nvars:\n- name: cluster_spec\nvalue:\nregion: us-east-1\nenv: dev\nnode_count: 10\npublic: false\n</code></pre>"},{"location":"use_tf_controller/with_AWS_EKS_IRSA/","title":"Use TF-controller with AWS EKS IRSA","text":"<p>AWS Elastic Kubernetes Service (EKS) offers IAM Roles for Service Accounts (IRSA) as a mechanism by which to provide credentials to Kubernetes pods. This can be used to provide the required AWS credentials to Terraform runners for performing plans and applies.</p> <p>You can use <code>eksctl</code> to associate an OIDC provider with your EKS cluster, for example:</p> <pre><code>eksctl utils associate-iam-oidc-provider --cluster CLUSTER_NAME --approve\n</code></pre> <p>Then follow the instructions here to add a trust policy to the IAM role which grants the necessary permissions for Terraform. Please note that if you have installed the controller following the README, then the <code>namespace:serviceaccountname</code> will be <code>flux-system:tf-runner</code>. You'll obtain a Role ARN to use in the next step.</p> <p>Finally, annotate the ServiceAccount for the <code>tf-runner</code> with the obtained Role ARN in your cluster:</p> <pre><code>kubectl annotate -n flux-system serviceaccount tf-runner eks.amazonaws.com/role-arn=ROLE_ARN\n</code></pre> <p>If deploying the <code>tf-controller</code> via Helm, this can be accomplished as follows:</p> <pre><code>values:\nrunner:\nserviceAccount:\nannotations:\neks.amazonaws.com/role-arn: ROLE_ARN\n</code></pre>"},{"location":"use_tf_controller/with_GitOps_dependency_management/","title":"Use TF-controller with GitOps dependency management","text":"<p>TF-controller supports GitOps dependency management. The GitOps dependency management feature is based on the similar technique implemented in the Kustomization controller of Flux.</p> <p>This means that you can use TF-controller to provision resources that depend on other resources at the GitOps level. For example, you can use TF-controller to provision an S3 bucket, and then use TF-controller to provision another resource to configure ACL for that bucket.</p> <p>GitOps dependency management is different from Terraform's HCL dependency management in the way that it is not based on Terraform's mechanism, which is controlled by the Terraform binary. Instead, it is implemented at the controller level, which means that each Terraform module is reconciled and can be managed independently, while still being able to depend on other modules.</p>"},{"location":"use_tf_controller/with_GitOps_dependency_management/#create-a-terraform-object","title":"Create a Terraform object","text":"<p>Similar to the same feature in the Kustomization controller, the dependency management feature is enabled by setting the <code>dependsOn</code> field in the <code>Terraform</code> object. The <code>dependsOn</code> field is a list of <code>Terraform</code> objects.</p> <p>When the dependency is not satisfied, the Terraform object will be in the <code>Unknown</code> state, and it will be retry again every <code>spec.retryInterval</code>. The retry interval is same as the <code>spec.interval</code> by default, and it can be configured separately by setting the <code>spec.retryInterval</code> field.</p> <p>First, create a <code>Terraform</code> object to provision the S3 bucket, name it <code>aws-s3-bucket</code>. The S3 bucket is provisioned by the Terraform module <code>aws_s3_bucket</code> in the OCI image <code>aws-package</code>. It is configured to use the <code>auto-apply</code> mode, and write outputs to the secret <code>aws-s3-bucket-outputs</code>.</p> <pre><code>---\napiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: aws-s3-bucket\nnamespace: flux-system\nspec:\npath: aws_s3_bucket\nvalues:\nbucket: my-tf-controller-test-bucket\ntags:\nEnvironment: Dev\nName: My bucket\nsourceRef:\nkind: OCIRepository\nname: aws-package\napprovePlan: auto\ninterval: 2m\ndestroyResourcesOnDeletion: true\nwriteOutputsToSecret:\nname: aws-s3-bucket-outputs\noutputs:\n- arn\n- bucket\nrunnerPodTemplate:\nspec:\nenvFrom:\n- secretRef:\nname: aws-credentials\n</code></pre> <p>Second, create a <code>Terraform</code> object to configure ACL for the S3 bucket, name it <code>aws-s3-bucket-acl</code>. The ACL is provisioned by the Terraform module <code>aws_s3_bucket_acl</code>, also from the OCI image <code>aws-package-v4.33.0</code>.</p> <p>In the <code>dependsOn</code> field, specify the <code>Terraform</code> object that provisions the S3 bucket. This means that the ACL will be configured only after the S3 bucket is provisioned, and has its outputs Secret written. We can read the outputs of the S3 bucket from the Secret <code>aws-s3-bucket-outputs</code>, by specifying the <code>spec.readInputsFromSecrets</code> field. The <code>spec.readInputsFromSecrets</code> field is a list of Secret objects.  Its <code>name</code> field is the name of the Secret, and its <code>as</code> field is the name of variable that can be used in the <code>spec.values</code> block.</p> <p>For example, the <code>spec.values.bucket</code> field in the <code>aws-s3-bucket-acl</code> Terraform object is set to <code>${{ .aws_s3_bucket.bucket }}</code>.</p> <p>Please note that we use <code>${{</code> and  <code>}}</code> as the delimiters for the variable name, instead of the Helm default ones, <code>{{</code> and <code>}}</code>.</p> <pre><code>---\napiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: aws-s3-bucket-acl\nnamespace: flux-system\nspec:\npath: aws_s3_bucket_acl\nvalues:\nacl: private\nbucket: ${{ .aws_s3_bucket.bucket }}\nsourceRef:\nkind: OCIRepository\nname: aws-package\napprovePlan: auto\ninterval: 3m\ndependsOn:\n- name: aws-s3-bucket\nreadInputsFromSecrets:\n- name: aws-s3-bucket-outputs\nas: aws_s3_bucket\nrunnerPodTemplate:\nspec:\nenvFrom:\n- secretRef:\nname: aws-credentials\n</code></pre>"},{"location":"use_tf_controller/with_GitOps_dependency_management/#avoid-kustomization-controllers-variable-substitution","title":"Avoid Kustomization controller's variable substitution","text":"<p>The Kustomization controller will substitute variables in the <code>Terraform</code> object, which will cause conflicts with the variable substitution in the GitOps dependency management feature. To avoid this, we need to add the <code>kustomize.toolkit.fluxcd.io/substitute: disabled</code> annotation to the <code>Terraform</code> object.</p> <pre><code>---\napiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: aws-s3-bucket-acl\nnamespace: flux-system\nannotations:\nkustomize.toolkit.fluxcd.io/substitute: disabled\nspec:\npath: aws_s3_bucket_acl\nvalues:\nacl: private\nbucket: ${{ .aws_s3_bucket.bucket }}\nsourceRef:\nkind: OCIRepository\nname: aws-package\napprovePlan: auto\ninterval: 3m\ndependsOn:\n- name: aws-s3-bucket\nreadInputsFromSecrets:\n- name: aws-s3-bucket-outputs\nas: aws_s3_bucket\nrunnerPodTemplate:\nspec:\nenvFrom:\n- secretRef:\nname: aws-credentials\n</code></pre>"},{"location":"use_tf_controller/with_Terraform_Enterprise/","title":"Use TF-controller with Terraform Enterprise","text":""},{"location":"use_tf_controller/with_Terraform_Enterprise/#terraform-enterprise-integration","title":"Terraform Enterprise Integration","text":"<p>Starting from v0.9.5, Weave TF-controller officially supports integration to Terraform Cloud (TFC) and  Terraform Enterprise (TFE). Here are the steps to set up TF-controller for your TFE instance.</p> <p></p>"},{"location":"use_tf_controller/with_Terraform_Enterprise/#terraform-login","title":"Terraform Login","text":"<p>First, you need to obtain an API token from your TFE. You can use <code>terraform login</code> command to do so.</p> <pre><code>terraform login tfe.dev.example.com\n</code></pre> <p>Then you can find your API token inside <code>$HOME/.terraform.d/credentials.tfrc.json</code>. Content of the file will look like this:</p> <pre><code>{\n\"credentials\": {\n\"tfe.dev.example.com\": {\n\"token\": \"mXXXXXXXXX.atlasv1.ixXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n}\n}\n}\n</code></pre>"},{"location":"use_tf_controller/with_Terraform_Enterprise/#prepare-an-tfrc-file","title":"Prepare an TFRC file","text":"<p>TF-controller accepts an TFRC file in the HCL format. So you have to prepare <code>terraform.tfrc</code> file using contents from above. <pre><code>credentials \"tfe.dev.example.com\" {\n  token = \"mXXXXXXXXX.atlasv1.ixXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n}\n</code></pre></p>"},{"location":"use_tf_controller/with_Terraform_Enterprise/#create-a-secret","title":"Create a Secret","text":"<p>We will now create a Kubernetes Secret from your<code>terraform.tfrc</code> file,  name it <code>tfe-cli-config</code> and put it inside the <code>flux-system</code> namespace.</p> <pre><code>kubectl create secret generic \\\ntfe-cli-config \\\n--namespace=flux-system \\\n--from-file=terraform.tfrc=./terraform.tfrc\n</code></pre>"},{"location":"use_tf_controller/with_Terraform_Enterprise/#terraform-object","title":"Terraform Object","text":"<p>In your Terraform object, you'll have to 1. disable the backend by setting <code>spec.backendConfig.disable: true</code>, and 2. point <code>spec.cliConfigSecretRef:</code> to the Secret created in the previous step, like this:</p> <pre><code>---\napiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: tfe-demo\nnamespace: flux-system\nspec:\napprovePlan: auto\ninterval: 2m\npath: ./terraform/tfe-demo\nbackendConfig:\ndisable: true\ncliConfigSecretRef:\nname: tfe-cli-config\nnamespace: flux-system\nvars:\n- name: subject\nvalue: World\nsourceRef:\nkind: GitRepository\nname: flux-system\nnamespace: flux-system\nwriteOutputsToSecret:\nname: tfe-helloworld-output\noutputs:\n- greeting\n</code></pre>"},{"location":"use_tf_controller/with_Terraform_Enterprise/#terraform-module","title":"Terraform Module","text":"<p>Don't forget that you need to tell your Terraform model to use your enterprise instance as well. Here's an example, <pre><code>terraform {\n  required_version = \"&gt;= 1.1.0\"\n  cloud {\n    hostname = \"tfe.dev.example.com\"\n    organization = \"weaveworks\"\n\n    workspaces {\n      name = \"dev\"\n    }\n  }\n}\n\nvariable \"subject\" {\n   type = string\n   default = \"World\"\n   description = \"Subject to hello\"\n}\n\noutput \"greeting\" {\n  value = \"Hello ${var.subject} from Terraform Enterprise\"\n}\n</code></pre></p>"},{"location":"use_tf_controller/with_Terraform_Enterprise/#terraform-cloud","title":"Terraform Cloud","text":"<p>For connecting to Terraform Cloud, please replace your hostname to <code>app.terraform.io</code>.</p>"},{"location":"use_tf_controller/with_a_custom_backend/","title":"Use TF-controller with a custom backend","text":"<p>By default, <code>tf-controller</code> will use the Kubernetes backend to store the Terraform state file (tfstate) in cluster.</p> <p>The tfstate is stored in a secret named: <code>tfstate-${workspace}-${secretSuffix}</code>. The default <code>suffix</code> will be the name of the Terraform resource, however you may override this setting using <code>.spec.backendConfig.secretSuffix</code>. The default <code>workspace</code> name is \"default\", you can also override the workspace by setting <code>.spec.workspace</code> to another value.</p> <p>If you wish to use a custom backend, you can configure it by defining the <code>.spec.backendConfig.customConfiguration</code> with one of the backends such as GCS or S3, for example:</p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\napprovePlan: auto\nbackendConfig:\ncustomConfiguration: |\nbackend \"s3\" {\nbucket                      = \"s3-terraform-state1\"\nkey                         = \"dev/terraform.tfstate\"\nregion                      = \"us-east-1\"\nendpoint                    = \"http://localhost:4566\"\nskip_credentials_validation = true\nskip_metadata_api_check     = true\nforce_path_style            = true\ndynamodb_table              = \"terraformlock\"\ndynamodb_endpoint           = \"http://localhost:4566\"\nencrypt                     = true\n}\ninterval: 1m\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\nrunnerPodTemplate:\nspec:\nimage: registry.io/tf-runner:xyz\n</code></pre>"},{"location":"use_tf_controller/with_an_OCI_Artifact_as_Source/","title":"Use TF-controller with an OCI Artifact as Source","text":"<p>To use OCI artifacts as the source of Terraform objects, you need Flux 2 version v0.32.0 or higher.</p> <p>Assuming that you have Terraform files (your root module may contain sub-modules) under ./modules, you can use Flux CLI to create an OCI artifact for your Terraform modules by running the following commands:</p> <pre><code>flux push artifact oci://ghcr.io/tf-controller/helloworld:$(git rev-parse --short HEAD) \\\n--path=\"./modules\" \\\n--source=\"$(git config --get remote.origin.url)\" \\\n--revision=\"$(git branch --show-current)/$(git rev-parse HEAD)\"\nflux tag artifact oci://ghcr.io/tf-controller/helloworld:$(git rev-parse --short HEAD) \\\n--tag main\n</code></pre> <p>Then you define a source (<code>OCIRepository</code>), and use it as the <code>sourceRef</code> of your Terraform object.</p> <pre><code>---\napiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: OCIRepository\nmetadata:\nname: helloworld-oci\nspec:\ninterval: 1m\nurl: oci://ghcr.io/tf-controller/helloworld\nref:\ntag: main\n---\napiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: helloworld-tf-oci\nspec:\npath: ./\napprovePlan: auto\ninterval: 1m\nsourceRef:\nkind: OCIRepository\nname: helloworld-oci\nwriteOutputsToSecret:\nname: helloworld-outputs\n</code></pre>"},{"location":"use_tf_controller/with_drift_detection_disabled/","title":"Use TF-controller with drift detection disabled","text":"<p>Drift detection is enabled by default. You can set <code>.spec.disableDriftDetection: true</code> to disable it.</p> <pre><code>apiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: helloworld\nnamespace: flux-system\nspec:\napprovePlan: auto\ndisableDriftDetection: true\ninterval: 1m\npath: ./\nsourceRef:\nkind: GitRepository\nname: helloworld\nnamespace: flux-system\n</code></pre>"},{"location":"use_tf_controller/with_primitive_modules/","title":"Use TF-controller with primitive modules","text":"<p>This document describes how to use the Weave TF-controller with a primitive module. It requires TF-controller v0.13+ to run the example.</p>"},{"location":"use_tf_controller/with_primitive_modules/#what-is-a-primitive-module","title":"What is a primitive module?","text":"<p>It's a Terraform module that contains only a single resource.</p> <ul> <li>A Terraform primitive module must contains the \"values\" variable.</li> <li>The \"values\" variable must be an object with fields of optional types.</li> <li>The module must be placed under a directory, which is named after the resource.</li> <li>The directory can optionally contain other files, for example the .terraform.lock.hcl.</li> <li>We call a set of primitive modules bundled into an OCI image, a package.</li> </ul>"},{"location":"use_tf_controller/with_primitive_modules/#hello-world-primitive-module","title":"Hello World Primitive Module","text":"<p>Here is an example of how a primitive module can be defined in YAML. Assume that we have a ready-to-use OCI image with a primitive module for the imaginary resource <code>aws_hello_world</code>, and the image is tagged as <code>ghcr.io/tf-controller/hello-primitive-modules/v4.32.0:v1</code>.</p> <p>We'll use the following Terraform object definition to provision the resource.</p> <p>First, we need to create a Terraform object with the <code>spec.sourceRef.kind</code> field  set to <code>OCIRepository</code> and the <code>spec.sourceRef.name</code> field set to the name of the OCIRepository object.</p> <p>Second, we need to set the <code>spec.path</code> field to the name of the resource, in this case <code>aws_hello_world</code>.</p> <p>Third, we need to set the <code>spec.values</code> field to the values of the resource. This is a YAML object that will be converted to an HCL variable, and passed to the Terraform module.</p> <p>Finally, we need to set the <code>spec.approvePlan</code> field to <code>auto</code> to automatically approve the plan.</p> <pre><code>---\napiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: OCIRepository\nmetadata:\nname: hello-package-v4.32.0\nnamespace: flux-system\nspec:\ninterval: 30s\nurl: oci://ghcr.io/tf-controller/hello-primitive-modules/v4.32.0\nref:\ntag: v1\n---\napiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\nname: hello-world\nnamespace: flux-system\nspec:\npath: aws_hello_world\nvalues:\ngreeting: Hi\nsubject: my world\nsourceRef:\nkind: OCIRepository\nname: hello-package-v4.32.0\ninterval: 1h0m\napprovePlan: auto\n</code></pre>"},{"location":"use_tf_controller/with_the_ready_to_use_AWS_package/","title":"with the ready to use AWS package","text":""},{"location":"use_tf_controller/with_the_ready_to_use_AWS_package/#use-tf-controller-with-the-ready-to-use-aws-package","title":"Use TF-controller with the ready-to-use AWS package","text":"<p>This document describes how to use the Weave TF-controller with the ready-to-use AWS package. It requires TF-controller v0.13+ to run the example.</p>"},{"location":"use_tf_controller/with_the_ready_to_use_AWS_package/#what-is-a-package","title":"What is a package?","text":"<p>A package is a collection of primitive Terraform modules that are bundled into an OCI image. You can think of a TF-controller's package as a thin wrapper around a Terraform module provider, and a TF-controller primitive module as a thin wrapper around a Terraform resource or a root module.</p> <p>We will provide a set of ready-to-use packages for the most popular cloud providers. Currently, we ship the package for AWS only.</p>"},{"location":"use_tf_controller/with_the_ready_to_use_AWS_package/#aws-package","title":"AWS Package","text":"<p>To provide the out-of-the-box experience, the AWS Package is installed by default when you installed the TF-controller. Unlike other IaC implementation, our package model is designed to be very lightweight as a package is just a set of TF files in the form of OCI.  Packages would not put any burden to your cluster. However, you can opt this package out by setting <code>awsPackage.install: false</code> in your Helm chart values.</p> <p>If you run <code>flux get sources oci</code> you should see the AWS package installed in your cluster listed as <code>aws-package</code>.</p> <pre><code>flux get sources oci\nNAME          REVISION                    SUSPENDED   READY   MESSAGE                                                                                                         aws-package   v4.38.0-v1alpha11/6033f3b   False       True    stored artifact for digest 'v4.38.0-v1alpha11/6033f3b'\n</code></pre>"},{"location":"use_tf_controller/with_the_ready_to_use_AWS_package/#a-step-by-step-tutorial","title":"A step-by-step tutorial","text":"<p>This section describes how to use the AWS package to provision an S3 bucket with ACL using the TF-controller.</p>"},{"location":"use_tf_controller/with_the_ready_to_use_AWS_package/#create-a-kind-local-cluster","title":"Create a KinD local cluster","text":"<p>If you don't have a Kubernetes cluster, you can create a KinD cluster with the following command:</p> <pre><code>kind create cluster\n</code></pre>"},{"location":"use_tf_controller/with_the_ready_to_use_AWS_package/#install-flux","title":"Install Flux","text":"<p>After you have a Kubernetes cluster, you can install Flux with the following command:</p> <pre><code>flux install\n</code></pre>"},{"location":"use_tf_controller/with_the_ready_to_use_AWS_package/#install-tf-controller","title":"Install TF-controller","text":"<p>Then, you can install the TF-controller with the following command:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/weaveworks/tf-controller/main/docs/release.yaml\n</code></pre>"},{"location":"use_tf_controller/with_the_ready_to_use_AWS_package/#setup-aws-credentials","title":"Setup AWS credentials","text":"<p>To provision AWS resources, you need to provide the AWS credentials to your Terraform objects. You can do this by creating a secret with the AWS credentials and reference it in each of your Terraform objects.</p> <pre><code>```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: aws-credentials\n  namespace: flux-system\ntype: Opaque\nstringData:\n  AWS_ACCESS_KEY_ID: Axxxxxxxxxxxxxxxxxxx\n  AWS_SECRET_ACCESS_KEY: qxxxxxxxxxxxxxxxxxxxxxxxxx\n  AWS_REGION: us-east-1 # the region you want\n</code></pre> <p>To apply the secret, run the following command:</p> <pre><code>kubectl apply -f aws-credentials.yaml\n</code></pre>"},{"location":"use_tf_controller/with_the_ready_to_use_AWS_package/#setup-aws-bucket-and-acl","title":"Setup AWS Bucket and ACL","text":"<p>Now, you can create two Terraform objects, one for an S3 bucket, another one for ACL. Please note that we are using GitOps dependencies to make sure the ACL is created after the bucket is created. You can read more about the GitOps dependencies in the GitOps dependencies document.</p> <pre><code>```yaml\n---\napiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\n  name: aws-s3-bucket\n  namespace: flux-system\n  labels:\n    tf.weave.works/composite: s3-bucket\nspec:\n  path: aws_s3_bucket\n  values:\n    bucket: my-tf-controller-test-bucket\n    tags:\n      Environment: Dev\n      Name: My bucket\n  sourceRef:\n    kind: OCIRepository\n    name: aws-package\n  approvePlan: auto\n  retryInterval: 10s\n  interval: 2m\n  destroyResourcesOnDeletion: true\nwriteOutputsToSecret:\n    name: aws-s3-bucket-outputs\n    outputs:\n    - arn\n    - bucket\n  runnerPodTemplate:\n    spec:\n      envFrom:\n      - secretRef:\n          name: aws-credentials\n---\napiVersion: infra.contrib.fluxcd.io/v1alpha1\nkind: Terraform\nmetadata:\n  name: example-bucket-acl\n  namespace: flux-system\n  labels:\n    tf.weave.works/composite: s3-bucket\nspec:\n  path: aws_s3_bucket_acl\n  values:\n    acl: private\n    bucket: ${{ .aws_s3_bucket.bucket }}\nsourceRef:\n    kind: OCIRepository\n    name: aws-package\n  approvePlan: auto\n  retryInterval: 10s\n  interval: 3m\n  dependsOn:\n  - name: aws-s3-bucket\n  readInputsFromSecrets:\n  - name: aws-s3-bucket-outputs\n    as: aws_s3_bucket\n  destroyResourcesOnDeletion: true\nrunnerPodTemplate:\n    spec:\n      envFrom:\n      - secretRef:\n          name: aws-credentials\n</code></pre>"}]}